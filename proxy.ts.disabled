import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"
import { updateSession } from "@/lib/supabase/middleware"
import { createClient } from "@/lib/supabase/server"
import { UserRole } from "@/lib/auth/roles"

/**
 * Route Access Control with RBAC
 * Updated: 2025-10-31
 * Integrated with Phase 11 RBAC and Phase 12 Authentication
 * See: docs/ACCESS_CONTROL_MATRIX.md for full documentation
 */

// Public Routes (no authentication required)
const PUBLIC_ROUTES = [
  "/",
  "/about",
  "/contact",
  "/pricing",
  "/faq",
  "/features",
  "/privacy",
  "/terms",
  "/pdpa",
  "/demo",
  "/analysis", // Free tier analysis
  "/auth/login",
  "/auth/register",
]

// Authenticated Routes (login required, any role)
const AUTHENTICATED_ROUTES = [
  "/profile",
  "/analysis/results",
  "/analysis/history",
  "/booking",
]

// Premium Routes (requires Premium or higher)
const PREMIUM_ROUTES = [
  "/ar-simulator",
  "/treatment-plans",
  "/chat",
]

// Clinic Routes (requires Clinic Staff or Admin)
const CLINIC_ROUTE_PATTERNS = ["/clinic"]

// Sales Routes (requires Sales Staff)
const SALES_ROUTE_PATTERNS = ["/sales"]

// Admin Routes (requires Super Admin)
const ADMIN_ROUTE_PATTERNS = ["/admin", "/super-admin"]

function isPublicRoute(pathname: string): boolean {
  return PUBLIC_ROUTES.includes(pathname) || pathname.startsWith("/api/")
}

function isAuthenticatedRoute(pathname: string): boolean {
  return AUTHENTICATED_ROUTES.some((route) => pathname.startsWith(route))
}

function isPremiumRoute(pathname: string): boolean {
  return PREMIUM_ROUTES.some((route) => pathname.startsWith(route))
}

function isClinicRoute(pathname: string): boolean {
  return CLINIC_ROUTE_PATTERNS.some((pattern) => pathname.startsWith(pattern))
}

function isSalesRoute(pathname: string): boolean {
  return SALES_ROUTE_PATTERNS.some((pattern) => pathname.startsWith(pattern))
}

function isAdminRoute(pathname: string): boolean {
  return ADMIN_ROUTE_PATTERNS.some((pattern) => pathname.startsWith(pattern))
}

/**
 * Get user role from database
 */
async function getUserRole(userId: string): Promise<UserRole | null> {
  try {
    const supabase = await createClient()
    const { data, error } = await supabase
      .from('users')
      .select('role')
      .eq('id', userId)
      .single()

    if (error || !data) {
      console.error('[Middleware] Error fetching user role:', error)
      return null
    }

    return data.role as UserRole
  } catch (error) {
    console.error('[Middleware] Exception fetching user role:', error)
    return null
  }
}

/**
 * Check if user has required role for route
 */
function hasRequiredRole(userRole: UserRole, pathname: string): boolean {
  // Admin routes - Super Admin only
  if (isAdminRoute(pathname)) {
    return userRole === UserRole.SUPER_ADMIN
  }

  // Sales routes - Sales Staff or Super Admin
  if (isSalesRoute(pathname)) {
    return userRole === UserRole.SALES_STAFF || userRole === UserRole.SUPER_ADMIN
  }

  // Clinic routes - Clinic Staff, Clinic Admin, or Super Admin
  if (isClinicRoute(pathname)) {
    return (
      userRole === UserRole.CLINIC_STAFF ||
      userRole === UserRole.CLINIC_ADMIN ||
      userRole === UserRole.SUPER_ADMIN
    )
  }

  // Premium routes - Premium Customer or higher
  if (isPremiumRoute(pathname)) {
    const roleHierarchy: Record<UserRole, number> = {
      [UserRole.PUBLIC]: 0,
      [UserRole.FREE_USER]: 1,
      [UserRole.PREMIUM_CUSTOMER]: 2,
      [UserRole.CLINIC_STAFF]: 3,
      [UserRole.CLINIC_ADMIN]: 4,
      [UserRole.SALES_STAFF]: 3,
      [UserRole.SUPER_ADMIN]: 5,
    }

    const userLevel = roleHierarchy[userRole] ?? 0
    const premiumLevel = roleHierarchy[UserRole.PREMIUM_CUSTOMER]

    return userLevel >= premiumLevel
  }

  // Authenticated routes - any authenticated user
  if (isAuthenticatedRoute(pathname)) {
    return userRole !== UserRole.PUBLIC
  }

  return true
}

export async function proxy(req: NextRequest) {
  const supabaseResponse = await updateSession(req)
  const pathname = req.nextUrl.pathname

  // Allow public routes
  if (isPublicRoute(pathname)) {
    return supabaseResponse
  }

  // Get user session
  const supabase = await createClient()
  const {
    data: { session },
  } = await supabase.auth.getSession()

  // Redirect to login if not authenticated
  if (!session) {
    console.log(`[Middleware] No session, redirecting to login from: ${pathname}`)
    return NextResponse.redirect(new URL("/auth/login", req.url))
  }

  // Get user role from database
  const userRole = await getUserRole(session.user.id)

  // If role not found, treat as public visitor
  if (!userRole) {
    console.warn(`[Middleware] No role found for user ${session.user.id}, treating as public visitor`)
    
    // Only allow authenticated routes for users without role
    if (isAuthenticatedRoute(pathname)) {
      return supabaseResponse
    }

    // Redirect to unauthorized for protected routes
    console.log(`[Middleware] User without role trying to access: ${pathname}`)
    return NextResponse.redirect(new URL("/unauthorized", req.url))
  }

  // Check if user has required role
  if (!hasRequiredRole(userRole, pathname)) {
    console.log(`[Middleware] User role ${userRole} insufficient for: ${pathname}`)
    return NextResponse.redirect(new URL("/unauthorized", req.url))
  }

  console.log(`[Middleware] User role ${userRole} authorized for: ${pathname}`)
  return supabaseResponse
}

export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)"],
}
